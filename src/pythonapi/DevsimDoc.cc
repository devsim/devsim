
static const char add_circuit_node_doc[] =
"    ds.add_circuit_node (name, value, variable_update)\n"
"\n"
"    Adds a circuit node for use in circuit or multi-device simulation\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name of the circuit node being created\n"
"    value : Float, optional\n"
"       initial value (default 0.0)\n"
"    variable_update : {'default', 'log_damp', 'positive'}\n"
"       update type for circuit variable\n"
;

static const char circuit_alter_doc[] =
"    ds.circuit_alter (name, param, value)\n"
"\n"
"    Alter the value of a circuit element parameter\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name of the circuit node being created\n"
"    param : str, optional\n"
"       parameter being modified (default 'value')\n"
"    value : Float\n"
"       value for the parameter\n"
;

static const char circuit_element_doc[] =
"    ds.circuit_element (name, value, n1, n2, acreal, acimag)\n"
"\n"
"    Adds a circuit element external to the devices\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name of the circuit element being created.  A prefix of 'V' is for voltage source, 'I' for current source, 'R' for resistor, 'L' for inductor, and 'C' for capacitor.\n"
"    value : Float, optional\n"
"       value for the default parameter of the circuit element (default 0.0)\n"
"    n1 : str\n"
"       circuit node\n"
"    n2 : str\n"
"       circuit node\n"
"    acreal : Float, optional\n"
"       real part of AC source for voltage (default 0.0)\n"
"    acimag : Float, optional\n"
"       imag part of AC source for voltage (default 0.0)\n"
;

static const char circuit_node_alias_doc[] =
"    ds.circuit_node_alias (node, alias)\n"
"\n"
"    Create an alias for a circuit node\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    node : str\n"
"       circuit node being aliased\n"
"    alias : str\n"
"       alias for the circuit node\n"
;

static const char get_circuit_equation_number_doc[] =
"    ds.get_circuit_equation_number (node)\n"
"\n"
"    Returns the row number correspond to circuit node in a region.  Values are only valid when during the course of a solve.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    node : str\n"
"       circuit node\n"
;

static const char get_circuit_node_list_doc[] =
"    ds.get_circuit_node_list ()\n"
"\n"
"    Gets the list of the nodes in the circuit.\n"
;

static const char get_circuit_node_value_doc[] =
"    ds.get_circuit_node_value (solution, node)\n"
"\n"
"    Gets the value of a circuit node for a given solution type.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    solution : str, optional\n"
"       name of the solution. 'dcop' is the name for the DC solution (default 'dcop')\n"
"    node : str\n"
"       circuit node of interest\n"
;

static const char get_circuit_solution_list_doc[] =
"    ds.get_circuit_solution_list ()\n"
"\n"
"    Gets the list of available circuit solutions.\n"
;

static const char set_circuit_node_value_doc[] =
"    ds.set_circuit_node_value (solution, node, value)\n"
"\n"
"    Sets the value of a circuit node for a given solution type.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    solution : str, optional\n"
"       name of the solution. 'dcop' is the name for the DC solution (default 'dcop')\n"
"    node : str\n"
"       circuit node of interest\n"
"    value : Float, optional\n"
"       new value (default 0.0)\n"
;

static const char contact_equation_doc[] =
"    ds.contact_equation (device, contact, name, variable_name, circuit_node, edge_charge_model, edge_current_model, edge_model, element_charge_model, element_current_model, element_model, node_charge_model, node_current_model, node_model)\n"
"\n"
"    Create a contact equation on a device\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    name : str\n"
"       Name of the contact equation being created\n"
"    variable_name : str, optional\n"
"       The variable name is used to determine the bulk equation we are replacing at this contact\n"
"    circuit_node : str, optional\n"
"       Name of the circuit we integrate the flux into\n"
"    edge_charge_model : str, optional\n"
"       Name of the edge model used to determine the charge at this contact\n"
"    edge_current_model : str, optional\n"
"       Name of the edge model used to determine the current flowing out of this contact\n"
"    edge_model : str, optional\n"
"       Name of the edge model being integrated at each edge at this contact\n"
"    element_charge_model : str, optional\n"
"       Name of the element edge model used to determine the charge at this contact\n"
"    element_current_model : str, optional\n"
"       Name of the element edge model used to determine the current flowing out of this contact\n"
"    element_model : str, optional\n"
"       Name of the element edge model being integrated at each edge at this contact\n"
"    node_charge_model : str, optional\n"
"       Name of the node model used to determine the charge at this contact\n"
"    node_current_model : str, optional\n"
"       Name of the node model used to determine the current flowing out of this contact\n"
"    node_model : str, optional\n"
"       Name of the node_model being integrated at each node at this contact\n"
;

static const char custom_equation_doc[] =
"    ds.custom_equation (name, procedure)\n"
"\n"
"    Custom equation assembly.  See :ref:`models__customequation` for a description of how the function should be structured.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name of the custom equation being created\n"
"    procedure : str\n"
"       The procedure to be called\n"
;

static const char delete_contact_equation_doc[] =
"    ds.delete_contact_equation (device, contact, name)\n"
"\n"
"    This command deletes an equation from a contact.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    name : str\n"
"       Name of the contact equation being deleted\n"
;

static const char delete_equation_doc[] =
"    ds.delete_equation (device, region, name)\n"
"\n"
"    This command deletes an equation from a region.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the equation being deleted\n"
;

static const char delete_interface_equation_doc[] =
"    ds.delete_interface_equation (device, interface, name)\n"
"\n"
"    This command deletes an equation from an interface.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    name : str\n"
"       Name of the interface equation being deleted\n"
;

static const char equation_doc[] =
"    ds.equation (device, region, name, variable_name, node_model, edge_model, edge_volume_model, time_node_model, element_model, volume_model, variable_update)\n"
"\n"
"    Specify an equation to solve on a device\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the equation being created\n"
"    variable_name : str\n"
"       Name of the node_solution being solved\n"
"    node_model : str, optional\n"
"       Name of the node_model being integrated at each node in the device volume\n"
"    edge_model : str, optional\n"
"       Name of the edge model being integrated over each edge in the device volume\n"
"    edge_volume_model : str, optional\n"
"       Name of the edge model being integrated over the volume of each edge in the device volume\n"
"    time_node_model : str, optional\n"
"       Name of the time dependent node_model being integrated at each node in the device volume\n"
"    element_model : str, optional\n"
"       Name of the element_model being integrated over each edge in the device volume\n"
"    volume_model : str, optional\n"
"       Name of the element_model being integrated over the volume of each edge in the device volume\n"
"    variable_update : str, optional\n"
"       update type for circuit variable (default 'default')\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    The integration variables can be changed in 2D for cylindrical coordinate systems by setting the appropriate parameters as described in :ref:`sec__cylindrical`.\n"
"\n"
"    In order to set the node volumes for integration of the ``edge_volume_model``, it is possible to do something like this:\n"
"\n"
"    ..\n"
"      ds.edge_model(device=\"device\", region=\"region\", name=\"EdgeNodeVolume\", equation=\"0.5*SurfaceArea*EdgeLength\")\n"
"      ds.set_parameter(name=\"edge_node0_volume_model\", value=\"EdgeNodeVolume\")\n"
"      ds.set_parameter(name=\"edge_node1_volume_model\", value=\"EdgeNodeVolume\")\n"
"\n"
;

static const char get_contact_equation_command_doc[] =
"    ds.get_contact_equation_command (device, contact, name)\n"
"\n"
"    This command gets the options used when creating this contact equation.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    name : str\n"
"       Name of the contact equation being command options returned\n"
;

static const char get_contact_equation_list_doc[] =
"    ds.get_contact_equation_list (device, contact)\n"
"\n"
"    This command gets a list of equations on the specified contact.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
;

static const char get_equation_command_doc[] =
"    ds.get_equation_command (device, region, name)\n"
"\n"
"    This command gets the options used when creating this equation.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the equation being command options returned\n"
;

static const char get_equation_list_doc[] =
"    ds.get_equation_list (device, region)\n"
"\n"
"    This command gets a list of equations on the specified region.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
;

static const char get_equation_numbers_doc[] =
"    ds.get_equation_numbers (device, region, equation, variable)\n"
"\n"
"    Returns a list of the equation numbers corresponding to each node in a region.  Values are only valid when during the course of a solve.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    equation : str, optional\n"
"       Name of the equation\n"
"    variable : str, optional\n"
"       Name of the variable\n"
;

static const char get_interface_equation_command_doc[] =
"    ds.get_interface_equation_command (device, interface, name)\n"
"\n"
"    This command gets the options used when creating this interface equation.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    name : str\n"
"       Name of the interface equation being command options returned\n"
;

static const char get_interface_equation_list_doc[] =
"    ds.get_interface_equation_list (device, interface)\n"
"\n"
"    This command gets a list of equations on the specified interface.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
;

static const char interface_equation_doc[] =
"    ds.interface_equation (device, interface, name, variable_name, interface_model, type)\n"
"\n"
"    Command to specify an equation at an interface\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    name : str\n"
"       Name of the interface equation being created\n"
"    variable_name : str\n"
"       The variable name is used to determine the bulk equation we are coupling this interface to\n"
"    interface_model : str\n"
"       When specified, the bulk equations on both sides of the interface are integrated together.  This model is then used to specify how nodal quantities on both sides of the interface are balanced\n"
"    type : str\n"
"       Specifies the type of boundary condition\n"
;

static const char get_contact_list_doc[] =
"    ds.get_contact_list (device)\n"
"\n"
"    Gets a list of contacts on a device.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
;

static const char get_device_list_doc[] =
"    ds.get_device_list ()\n"
"\n"
"    Gets a list of devices on the simulation.\n"
;

static const char get_element_node_list_doc[] =
"    ds.get_element_node_list (device, region, contact, interface)\n"
"\n"
"    Gets a list of nodes for each element on a device, region, contact, or interface.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    contact : str, optional\n"
"       If specified, gets the element nodes for the contact on the specified region\n"
"    interface : str, optional\n"
"       If specified, gets the element nodes for the interface on the specified region\n"
;

static const char get_interface_list_doc[] =
"    ds.get_interface_list (device)\n"
"\n"
"    Gets a list of interfaces on a device.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
;

static const char get_region_list_doc[] =
"    ds.get_region_list (device, contact, interface)\n"
"\n"
"    Gets a list of regions on a device, contact, or interface.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str, optional\n"
"       If specified, gets the name of the region belonging to this contact on the device\n"
"    interface : str, optional\n"
"       If specified, gets the name of the regions belonging to this interface on the device\n"
;

static const char add_db_entry_doc[] =
"    ds.add_db_entry (material, parameter, value, unit, description)\n"
"\n"
"    Adds an entry to the database\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    material : str\n"
"       Material name requested. ``global`` refers to all regions whose material does not have the parameter name specified\n"
"    parameter : str\n"
"       Parameter name\n"
"    value : str\n"
"       Value assigned for the parameter\n"
"    unit : str\n"
"       String describing the units for this parameter name\n"
"    description : str\n"
"       Description of the parameter for this material type.\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    The :meth:`ds.save_db` command is used to commit these added entries permanently to the database.\n"
;

static const char close_db_doc[] =
"    ds.close_db ()\n"
"\n"
"    Closes the database so that its entries are no longer available\n"
;

static const char create_db_doc[] =
"    ds.create_db (filename)\n"
"\n"
"    Create a database to store material properties\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    filename : str\n"
"       filename to create for the db\n"
;

static const char get_db_entry_doc[] =
"    ds.get_db_entry (material, parameter)\n"
"\n"
"    This command returns a list containing the value, unit, and description for the requested material db entry\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    material : str\n"
"       Material name\n"
"    parameter : str\n"
"       Parameter name\n"
;

static const char get_dimension_doc[] =
"    ds.get_dimension (device)\n"
"\n"
"    Get the dimension of the device\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
;

static const char get_material_doc[] =
"    ds.get_material (device, region)\n"
"\n"
"    Returns the material for the specified region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
"    region : str, optional\n"
"       The selected region\n"
;

static const char get_parameter_doc[] =
"    ds.get_parameter (device, region, name)\n"
"\n"
"    Get a parameter on a region, device, or globally.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
"    region : str, optional\n"
"       The selected region\n"
"    name : str\n"
"       Name of the parameter name being retrieved\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    Note that the ``device`` and ``region`` options are optional.  If the region is not specified, the parameter is retrieved for the entire device.  If the device is not specified, the parameter is retrieved for all devices.  If the parameter is not found on the region, it is retrieved on the device.  If it is not found on the device, it is retrieved over all devices.\n"
;

static const char get_parameter_list_doc[] =
"    ds.get_parameter_list (device, region)\n"
"\n"
"    Get list of parameter names on region, device, or globally\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
"    region : str, optional\n"
"       The selected region\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    Note that the ``device`` and ``region`` options are optional.  If the region is not specified, the parameter is retrieved for the entire device.  If the device is not specified, the parameter is retrieved for all devices.  Unlike the :meth:`ds.getParameter`, parameter names on the the device are not retrieved if they do not exist on the region.  Similarly, the parameter names over all devices are not retrieved if they do not exist on the device.\n"
;

static const char open_db_doc[] =
"    ds.open_db (filename, permissions)\n"
"\n"
"    Open a database storing material properties\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    filename : str\n"
"       filename to create for the db\n"
"    permissions : str, optional\n"
"       permissions on the db (default 'readonly')\n"
;

static const char save_db_doc[] =
"    ds.save_db ()\n"
"\n"
"    Saves any new or modified db entries to the database file\n"
;

static const char set_material_doc[] =
"    ds.set_material (device, region, material)\n"
"\n"
"    Sets the new material for a region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
"    region : str, optional\n"
"       The selected region\n"
"    material : str\n"
"       New material name\n"
;

static const char set_parameter_doc[] =
"    ds.set_parameter (device, region, name, value)\n"
"\n"
"    Set a parameter on region, device, or globally\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str, optional\n"
"       The selected device\n"
"    region : str, optional\n"
"       The selected region\n"
"    name : str\n"
"       Name of the parameter name being retrieved\n"
"    value : any\n"
"       value to set for the parameter\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    Note that the device and region options are optional.  If the region is not specified, the parameter is set for the entire device.  If the device is not specified, the parameter is set for all devices.\n"
;

static const char add_1d_contact_doc[] =
"    ds.add_1d_contact (material, mesh, name, tag)\n"
"\n"
"    Add a contact to a 1D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    material : str\n"
"       material for the contact being created\n"
"    mesh : str\n"
"       Mesh to add the contact to\n"
"    name : str\n"
"       Name for the contact being created\n"
"    tag : str\n"
"       Text label for the position to add the contact\n"
;

static const char add_1d_interface_doc[] =
"    ds.add_1d_interface (mesh, tag, name)\n"
"\n"
"    Add an interface to a 1D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the interface to\n"
"    tag : str\n"
"       Text label for the position to add the interface\n"
"    name : str\n"
"       Name for the interface being created\n"
;

static const char add_1d_mesh_line_doc[] =
"    ds.add_1d_mesh_line (mesh, tag, pos, ns, ps)\n"
"\n"
"    Add a mesh line to a 1D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the line to\n"
"    tag : str, optional\n"
"       Text label for the position\n"
"    pos : str\n"
"       Position for the mesh point\n"
"    ns : Float, optional\n"
"       Spacing from this point in the negative direction (default ps value)\n"
"    ps : Float\n"
"       Spacing from this point in the positive direction\n"
;

static const char add_1d_region_doc[] =
"    ds.add_1d_region (mesh, tag1, tag2, region, material)\n"
"\n"
"    Add a region to a 1D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the line to\n"
"    tag1 : str\n"
"       Text label for the position bounding the region being added\n"
"    tag2 : str\n"
"       Text label for the position bounding the region being added\n"
"    region : str\n"
"       Name for the region being created\n"
"    material : str\n"
"       Material for the region being created\n"
;

static const char add_2d_contact_doc[] =
"    ds.add_2d_contact (name, material, mesh, region, xl, xh, yl, yh, bloat)\n"
"\n"
"    Add an interface to a 2D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name for the contact being created\n"
"    material : str\n"
"       material for the contact being created\n"
"    mesh : str\n"
"       Mesh to add the contact to\n"
"    region : str\n"
"       Name of the region included in the contact\n"
"    xl : Float, optional\n"
"       x position for corner of bounding box (default -MAXDOUBLE)\n"
"    xh : Float, optional\n"
"       x position for corner of bounding box (default +MAXDOUBLE)\n"
"    yl : Float, optional\n"
"       y position for corner of bounding box (default -MAXDOUBLE)\n"
"    yh : Float, optional\n"
"       y position for corner of bounding box (default +MAXDOUBLE)\n"
"    bloat : Float, optional\n"
"       Extend bounding box by this amount when search for mesh to include in region (default 1e-10)\n"
;

static const char add_2d_interface_doc[] =
"    ds.add_2d_interface (mesh, name, region0, region1, xl, xh, yl, yh, bloat)\n"
"\n"
"    Add an interface to a 2D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the interface to\n"
"    name : str\n"
"       Name for the interface being created\n"
"    region0 : str\n"
"       Name of the region included in the interface\n"
"    region1 : str\n"
"       Name of the region included in the interface\n"
"    xl : Float, optional\n"
"       x position for corner of bounding box (default -MAXDOUBLE)\n"
"    xh : Float, optional\n"
"       x position for corner of bounding box (default +MAXDOUBLE)\n"
"    yl : Float, optional\n"
"       y position for corner of bounding box (default -MAXDOUBLE)\n"
"    yh : Float, optional\n"
"       y position for corner of bounding box (default +MAXDOUBLE)\n"
"    bloat : Float, optional\n"
"       Extend bounding box by this amount when search for mesh to include in region (default 1e-10)\n"
;

static const char add_2d_mesh_line_doc[] =
"    ds.add_2d_mesh_line (mesh, pos, ns, ps)\n"
"\n"
"    Add a mesh line to a 2D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the line to\n"
"    pos : str\n"
"       Position for the mesh point\n"
"    ns : Float\n"
"       Spacing from this point in the negative direction\n"
"    ps : Float\n"
"       Spacing from this point in the positive direction\n"
;

static const char add_2d_region_doc[] =
"    ds.add_2d_region (mesh, region, material, xl, xh, yl, yh, bloat)\n"
"\n"
"    Add a region to a 2D mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to add the region to\n"
"    region : str\n"
"       Name for the region being created\n"
"    material : str\n"
"       Material for the region being created\n"
"    xl : Float, optional\n"
"       x position for corner of bounding box (default -MAXDOUBLE)\n"
"    xh : Float, optional\n"
"       x position for corner of bounding box (default +MAXDOUBLE)\n"
"    yl : Float, optional\n"
"       y position for corner of bounding box (default -MAXDOUBLE)\n"
"    yh : Float, optional\n"
"       y position for corner of bounding box (default +MAXDOUBLE)\n"
"    bloat : Float, optional\n"
"       Extend bounding box by this amount when search for mesh to include in region (default 1e-10)\n"
;

static const char add_genius_contact_doc[] =
"    ds.add_genius_contact (genius_name, material, mesh, name, region)\n"
"\n"
"    Create a contact for an imported Genius mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    genius_name : str\n"
"       boundary condition name in the Genius CGNS file\n"
"    material : str\n"
"       material for the contact being created\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    name : str\n"
"       name of the contact begin created\n"
"    region : str\n"
"       region that the contact is attached to\n"
;

static const char add_genius_interface_doc[] =
"    ds.add_genius_interface (genius_name, mesh, name, region0, region1)\n"
"\n"
"    Create an interface for an imported Genius mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    genius_name : str\n"
"       boundary condition name in the Genius CGNS file\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    name : str\n"
"       name of the interface begin created\n"
"    region0 : str\n"
"       first region that the interface is attached to\n"
"    region1 : str\n"
"       second region that the interface is attached to\n"
;

static const char add_genius_region_doc[] =
"    ds.add_genius_region (genius_name, mesh, region, material)\n"
"\n"
"    Create a region for an imported Genius  mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    genius_name : str\n"
"       region name in the Genius CGNS file\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    region : str\n"
"       name of the region begin created\n"
"    material : str\n"
"       material for the region being created\n"
;

static const char add_gmsh_contact_doc[] =
"    ds.add_gmsh_contact (gmsh_name, material, mesh, name, region)\n"
"\n"
"    Create a mesh to import a Gmsh mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    gmsh_name : str\n"
"       physical group name in the Gmsh file\n"
"    material : str\n"
"       material for the contact being created\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    name : str\n"
"       name of the contact begin created\n"
"    region : str\n"
"       region that the contact is attached to\n"
;

static const char add_gmsh_interface_doc[] =
"    ds.add_gmsh_interface (gmsh_name, mesh, name, region0, region1)\n"
"\n"
"    Create an interface for an imported Gmsh mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    gmsh_name : str\n"
"       physical group name in the Gmsh file\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    name : str\n"
"       name of the interface begin created\n"
"    region0 : str\n"
"       first region that the interface is attached to\n"
"    region1 : str\n"
"       second region that the interface is attached to\n"
;

static const char add_gmsh_region_doc[] =
"    ds.add_gmsh_region (gmsh_name, mesh, region, material)\n"
"\n"
"    Create a region for an imported Gmsh mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    gmsh_name : str\n"
"       physical group name in the Gmsh file\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    region : str\n"
"       name of the region begin created\n"
"    material : str\n"
"       material for the region being created\n"
;

static const char create_1d_mesh_doc[] =
"    ds.create_1d_mesh (mesh)\n"
"\n"
"    Create a mesh to create a 1D device\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       name of the 1D mesh being created\n"
;

static const char create_2d_mesh_doc[] =
"    ds.create_2d_mesh (mesh)\n"
"\n"
"    Create a mesh to create a 2D device\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       name of the 2D mesh being created\n"
;

static const char create_contact_from_interface_doc[] =
"    ds.create_contact_from_interface (device, region, interface, material, name)\n"
"\n"
"    Creates a contact on a device from an existing interface\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    material : str\n"
"       material for the contact being created\n"
"    name : str\n"
"       name of the contact begin created\n"
;

static const char create_device_doc[] =
"    ds.create_device (mesh, device)\n"
"\n"
"    Create a device from a mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       name of the mesh being used to create a device\n"
"    device : str\n"
"       name of the device being created\n"
;

static const char create_genius_mesh_doc[] =
"    ds.create_genius_mesh (file, mesh)\n"
"\n"
"    This command reads in a Genius mesh written in the CGNS format\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    file : str\n"
"       name of the Genius mesh file being read into DEVSIM\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    If successful, this command will return a dictionary containing information about the regions and boundaries in the mesh.  Please see the example in :ref:`sec__geniusintro` for an example of how this information can be used for adding contacts and interfaces to the structure being created.\n"
"\n"
"      If the CGNS file was created with HDF as the underlying storage format, it may be necessary to convert it to ADF using the ``hdf2adf`` command before reading it into DEVSIM.  This command is available as part of the CGNS library when it is compiled with HDF support.  Please :ref:`additional__cgns` for availablility. }\n"
;

static const char create_gmsh_mesh_doc[] =
"    ds.create_gmsh_mesh (mesh, file, coordinates, elements, physical_names)\n"
"\n"
"    Create a mesh to import a Gmsh mesh\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       name of the mesh being generated\n"
"    file : str, optional\n"
"       name of the Gmsh mesh file being read into DEVSIM\n"
"    coordinates : list, optional\n"
"       List of coordinate positions on mesh.\n"
"    elements : list, optional\n"
"       List of elements on the mesh.\n"
"    physical_names : list, optional\n"
"       List of names for each contact, interface, and region on mesh.\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This file will import a Gmsh format mesh from a file.  Alternatively, the mesh structure may be passed in as as arguments:\n"
"\n"
"    ``coordinates`` is a float list of positions in the mesh.  Each coordinate adds an x, y, and z position so that the coordinate list length is 3 times the number of coordinates.\n"
"\n"
"    ``physical_names`` is a list of contact, interface, and region names.  It is referenced by index by the ``elements`` list. \n"
"\n"
"    ``elements`` is a list of elements.  Each element adds\n"
"\n"
"    * Element Type (float)\n"
"\n"
"      - 0 node\n"
"      - 1 edge \n"
"      - 2 triangle\n"
"      - 3 tetrahedron\n"
"\n"
"    * Physical Index\n"
"\n"
"      - This indexes into the ``physical_names`` list.\n"
"\n"
"    * Nodes\n"
"\n"
"      - Each node of the element indexes into the coordinates list.\n"
"\n"
;

static const char finalize_mesh_doc[] =
"    ds.finalize_mesh (mesh)\n"
"\n"
"    Finalize a mesh so no additional mesh specifications can be added and devices can be created.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    mesh : str\n"
"       Mesh to finalize\n"
;

static const char load_devices_doc[] =
"    ds.load_devices (file)\n"
"\n"
"    Load devices from a DEVSIM file\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    file : str\n"
"       name of the file to load the meshes from\n"
;

static const char write_devices_doc[] =
"    ds.write_devices (file, device, type)\n"
"\n"
"    Write a device to a file for visualization or restart\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    file : str\n"
"       name of the file to write the meshes to\n"
"    device : str, optional\n"
"       name of the device to write\n"
"    type : {'devsim', 'devsim_data', 'floops', 'tecplot', 'vtk'}\n"
"       format to use\n"
;

static const char contact_edge_model_doc[] =
"    ds.contact_edge_model (device, contact, name, equation, display_type)\n"
"\n"
"    Create an edge model evaluated at a contact\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    name : str\n"
"       Name of the contact edge model being created\n"
"    equation : str\n"
"       Equation used to describe the contact edge model being created\n"
"    display_type : {'vector', 'nodisplay', 'scalar'}\n"
"       Option for output display in graphical viewer\n"
;

static const char contact_node_model_doc[] =
"    ds.contact_node_model (device, contact, name, equation, display_type)\n"
"\n"
"    Create an node model evaluated at a contact\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    name : str\n"
"       Name of the contact node model being created\n"
"    equation : str\n"
"       Equation used to describe the contact node model being created\n"
"    display_type : {'scalar', 'nodisplay'}\n"
"       Option for output display in graphical viewer\n"
;

static const char cylindrical_edge_couple_doc[] =
"    ds.cylindrical_edge_couple (device, region)\n"
"\n"
"    This command creates the ``EdgeCouple`` model for 2D cylindrical simulation\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This model is only available in 2D.  The created variables are\n"
"\n"
"    - ``ElementCylindricalEdgeCouple`` (Element Edge Model)\n"
"    - ``CylindricalEdgeCouple`` (Edge Model)\n"
"\n"
"    The :meth:`ds.set_parameter` must be used to set\n"
"\n"
"    - ``raxis_variable``, the variable (``x`` or ``y``) which is the radial axis variable in the cylindrical coordinate system\n"
"    - ``raxis_zero``, the location of the z axis for the radial axis variable\n"
;

static const char cylindrical_node_volume_doc[] =
"    ds.cylindrical_node_volume (device, region)\n"
"\n"
"    This command creates the ``NodeVolume`` model for 2D cylindrical simulation\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This model is only available in 2D.  The created variables are\n"
"\n"
"    - ``ElementCylindricalNodeVolume@en0`` (Element Edge Model)\n"
"    - ``ElementCylindricalNodeVolume@en1`` (Element Edge Model)\n"
"    - ``CylindricalEdgeNodeVolume@n0`` (Edge Model)\n"
"    - ``CylindricalEdgeNodeVolume@n1`` (Edge Model)\n"
"    - ``CylindricalNodeVolume`` (Node Model)\n"
"\n"
"    The ``ElementCylindricalNodeVolume@en0`` and ``ElementCylindricalNodeVolume@en1`` represent the node volume at each end of the element edge.\n"
"\n"
"    The :meth:`ds.set_parameter` must be used to set\n"
"\n"
"    - ``raxis_variable``, the variable (``x`` or ``y``) which is the radial axis variable in the cylindrical coordinate system\n"
"    - ``raxis_zero``, the location of the z axis for the radial axis variable\n"
"\n"
;

static const char cylindrical_surface_area_doc[] =
"    ds.cylindrical_surface_area (device, region)\n"
"\n"
"    This command creates the ``SurfaceArea`` model for 2D cylindrical simulation\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This model is only available in 2D.  The created variables are\n"
"\n"
"    - ``CylindricalSurfaceArea`` (Node Model)\n"
"\n"
"    and is the cylindrical surface area along each contact and interface node in the device region.\n"
"\n"
"    The :meth:`ds.set_parameter` must be used to set\n"
"\n"
"    - ``raxis_variable``, the variable (``x`` or ``y``) which is the radial axis variable in the cylindrical coordinate system\n"
"    - ``raxis_zero``, the location of the z axis for the radial axis variable\n"
"\n"
;

static const char debug_triangle_models_doc[] =
"    ds.debug_triangle_models (device, region)\n"
"\n"
"    Debugging command used in the development of DEVSIM and used in regressions.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
;

static const char delete_edge_model_doc[] =
"    ds.delete_edge_model (device, region, name)\n"
"\n"
"    Deletes an edge model from a region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the edge model being deleted\n"
;

static const char delete_element_model_doc[] =
"    ds.delete_element_model (device, region, name)\n"
"\n"
"    Deletes a element model from a region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model being deleted\n"
;

static const char delete_interface_model_doc[] =
"    ds.delete_interface_model (device, interface, name)\n"
"\n"
"    Deletes an interface model from an interface\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    name : str\n"
"       Name of the interface model being deleted\n"
;

static const char delete_node_model_doc[] =
"    ds.delete_node_model (device, region, name)\n"
"\n"
"    Deletes a node model from a region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model being deleted\n"
;

static const char edge_average_model_doc[] =
"    ds.edge_average_model (device, region, node_model, edge_model, derivative, average_type)\n"
"\n"
"    Creates an edge model based on the node model values\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    node_model : str\n"
"       The node model from which we are creating the edge model.  If ``derivative`` is specified, the edge model is created from ``nodeModel:derivativeModel``\n"
"    edge_model : str\n"
"       The edge model name being created.  If ``derivative`` is specified, the edge models created are ``edgeModel:derivativeModel@n0`` ``edgeModel:derivativeModel@n1``, which are the derivatives with respect to the derivative model on each side of the edge\n"
"    derivative : str, optional\n"
"       The node model of the variable for which the derivative is being taken.  The node model ``nodeModel:derivativeModel`` is used to create the resulting edge models.\n"
"    average_type : str, optional\n"
"       The node models on both sides of the edge are averaged together to create one of the following types of averages. (default 'arithmetic')\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    For a node model, creates 2 edge models referring to the node model value at both ends of the edge.  For example, to calculate electric field:\n"
"\n"
"    ..\n"
"\n"
"      ds.edge_average_model(device=device, region=region, node_model=\"Potential\", edge_model=\"ElecticField\", average_type=\"negative_gradient\")\n"
"\n"
"    and the derivatives ``ElectricField:Potential@n0`` and ``ElectricField:Potential@n1`` are then created from\n"
"\n"
"    ..\n"
"\n"
"      ds.edge_average_model(device=device, region=region, node_model=\"Potential\", edge_model=\"ElecticField\", average_type=\"negative_gradient\", derivative=\"Potential\")\n"
;

static const char edge_from_node_model_doc[] =
"    ds.edge_from_node_model (device, region, node_model)\n"
"\n"
"    For a node model, creates an 2 edge models referring to the node model value at both ends of the edge.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    node_model : str\n"
"       The node model from which we are creating the edge model\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    For example, to calculate electric field:\n"
"\n"
"    ..\n"
"\n"
"      ds.edge_from_node_model(device=device, region=region, node_model=\"Potential\")\n"
"\n"
;

static const char edge_model_doc[] =
"    ds.edge_model (device, region, name, equation, display_type)\n"
"\n"
"    Creates an edge model based on an equation\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the edge model being created\n"
"    equation : str\n"
"       Equation used to describe the edge model being created\n"
"    display_type : str, optional\n"
"       Option for output display in graphical viewer (default 'scalar')\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    The ``vector`` option uses an averaging scheme for the edge values projected in the direction of each edge.  For a given model, ``model``, the generated components in the visualization files is:\n"
"\n"
"    - ``model_x_onNode``\n"
"    - ``model_y_onNode``\n"
"    - ``model_z_onNode`` (3D)\n"
"\n"
"    This averaging scheme does not produce accurate results, and it is recommended to use the :meth:`ds.element_from_edge_model` to create components better suited for visualization.  See :ref:`ch__visualization` for more information about creating data files for external visualization programs.\n"
;

static const char element_from_edge_model_doc[] =
"    ds.element_from_edge_model (device, region, edge_model, derivative)\n"
"\n"
"    Creates element edge models from an edge model\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    edge_model : str\n"
"       The edge model from which we are creating the element model\n"
"    derivative : str, optional\n"
"       The variable we are taking with respect to edge_model\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    For an edge model ``emodel``, creates an element models referring to the directional components on each edge of the element:\n"
"\n"
"    - ``emodel_x``\n"
"    - ``emodel_y``\n"
"\n"
"    If the ``derivative`` ``variable`` option is specified, the ``emodel@n0`` and ``emodel@n1`` are used to create:\n"
"\n"
"    - ``emodel_x:variable@en0``\n"
"    - ``emodel_y:variable@en0``\n"
"    - ``emodel_x:variable@en1``\n"
"    - ``emodel_y:variable@en1``\n"
"    - ``emodel_x:variable@en2``\n"
"    - ``emodel_y:variable@en2``\n"
"\n"
"    in 2D for each node on a triangular element. and \n"
"\n"
"    - ``emodel_x:variable@en0``\n"
"    - ``emodel_y:variable@en0``\n"
"    - ``emodel_z:variable@en0``\n"
"    - ``emodel_x:variable@en1``\n"
"    - ``emodel_y:variable@en1``\n"
"    - ``emodel_z:variable@en1``\n"
"    - ``emodel_x:variable@en2``\n"
"    - ``emodel_y:variable@en2``\n"
"    - ``emodel_z:variable@en2``\n"
"    - ``emodel_x:variable@en3``\n"
"    - ``emodel_y:variable@en3``\n"
"    - ``emodel_z:variable@en3``\n"
"\n"
"    in 3D for each node on a tetrahedral element.\n"
"\n"
"    The suffix ``en0`` refers to the first node on the edge of the element and ``en1`` refers to the second node.  ``en2`` and ``en3`` specifies the derivatives with respect the variable at the nodes opposite the edges on the element being considered.\n"
;

static const char element_from_node_model_doc[] =
"    ds.element_from_node_model (device, region, node_model)\n"
"\n"
"    Creates element edge models from a node model\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    node_model : str\n"
"       The node model from which we are creating the edge model\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This command creates an element edge model from a node model so that each corner of the element is represented.  A node model, ``nmodel``, would be be accessible as \n"
"\n"
"    - ``nmodel@en0``\n"
"    - ``nmodel@en1``\n"
"    - ``nmodel@en2``\n"
"    - ``nmodel@en3`` (3D)\n"
"\n"
"    where ``en0``, and ``en1`` refers to the nodes on the element's edge.  In 2D, ``en2`` refers to the node on the triangle node opposite the edge.  In 3D, ``en2`` and ``en3`` refers to the nodes on the nodes off the element edge on the tetrahedral element.\n"
;

static const char element_model_doc[] =
"    ds.element_model (device, region, name, equation, display_type)\n"
"\n"
"    Create a model evaluated on element edges.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the element edge model being created\n"
"    equation : str\n"
"       Equation used to describe the element edge model being created\n"
"    display_type : str, optional\n"
"       Option for output display in graphical viewer (default 'scalar')\n"
;

static const char get_edge_model_list_doc[] =
"    ds.get_edge_model_list (device, region)\n"
"\n"
"    Returns a list of the edge models on the device region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
;

static const char get_edge_model_values_doc[] =
"    ds.get_edge_model_values (device, region, name)\n"
"\n"
"    Get the edge model values calculated at each edge.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the edge model values being returned as a list\n"
;

static const char get_element_model_list_doc[] =
"    ds.get_element_model_list (device, region)\n"
"\n"
"    Returns a list of the element edge models on the device region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
;

static const char get_element_model_values_doc[] =
"    ds.get_element_model_values (device, region, name)\n"
"\n"
"    Get element model values at each element edge\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the element edge model values being returned as a list\n"
;

static const char get_interface_model_list_doc[] =
"    ds.get_interface_model_list (device, interface)\n"
"\n"
"    Returns a list of the interface models on the interface\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
;

static const char get_interface_model_values_doc[] =
"    ds.get_interface_model_values (device, interface, name)\n"
"\n"
"    Gets interface model values evaluated at each interface node.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    name : str\n"
"       Name of the interface model values being returned as a list\n"
;

static const char get_node_model_list_doc[] =
"    ds.get_node_model_list (device, region)\n"
"\n"
"    Returns a list of the node models on the device region\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
;

static const char get_node_model_values_doc[] =
"    ds.get_node_model_values (device, region, name)\n"
"\n"
"    Get node model values evaluated at each node in a region.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model values being returned as a list\n"
;

static const char interface_model_doc[] =
"    ds.interface_model (device, interface, equation)\n"
"\n"
"    Create an interface model from an equation.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"    equation : str\n"
"       Equation used to describe the interface node model being created\n"
;

static const char interface_normal_model_doc[] =
"    ds.interface_normal_model (device, region, interface)\n"
"\n"
"    Creates edge models whose components are based on direction and distance to an interface\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    interface : str\n"
"       Interface on which to apply this command\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This model creates the following edge models:\n"
"\n"
"    - ``iname_distance``\n"
"    - ``iname_normal_x`` (2D and 3D)\n"
"    - ``iname_normal_y`` (2D and 3D)\n"
"    - ``iname_normal_z`` (3D only)\n"
"\n"
"    where ``iname`` is the name of the interface.  The normals are of the closest node on the interface.  The sign is toward the interface.\n"
;

static const char node_model_doc[] =
"    ds.node_model (device, region, name, equation, display_type)\n"
"\n"
"    Create a node model from an equation.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model being created\n"
"    equation : str\n"
"       Equation used to describe the node model being created\n"
"    display_type : str, optional\n"
"       Option for output display in graphical viewer (default 'scalar')\n"
;

static const char node_solution_doc[] =
"    ds.node_solution (device, region, name)\n"
"\n"
"    Create node model whose values are set.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the solution being created\n"
;

static const char print_edge_values_doc[] =
"    ds.print_edge_values (device, region, name)\n"
"\n"
"    Print edge values for debugging.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the edge model values being printed to the screen\n"
;

static const char print_element_values_doc[] =
"    ds.print_element_values (device, region, name)\n"
"\n"
"    Print element values for debugging.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the element edge model values being printed to the screen\n"
;

static const char print_node_values_doc[] =
"    ds.print_node_values (device, region, name)\n"
"\n"
"    Print node values for debugging.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model values being printed to the screen\n"
;

static const char register_function_doc[] =
"    ds.register_function (name, nargs)\n"
"\n"
"    This command is used to register a new Python procedure for evaluation by SYMDIFF.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    name : str\n"
"       Name of the function\n"
"    nargs : str\n"
"       Number of arguments to the function\n"
;

static const char set_node_value_doc[] =
"    ds.set_node_value (device, region, name, index, value)\n"
"\n"
"    A uniform value is used if index is not specified.  Note that equation based node models will lose this value if their equation is recalculated.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model being whose value is being set\n"
"    index : int\n"
"       Index of node being set\n"
"    value : Float\n"
"       Value of node being set\n"
;

static const char set_node_values_doc[] =
"    ds.set_node_values (device, region, name, init_from, values)\n"
"\n"
"    Set node model values from another node model, or a list of values.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    name : str\n"
"       Name of the node model being initialized\n"
"    init_from : str, optional\n"
"       Node model we are using to initialize the node solution\n"
"    values : list, optional\n"
"       List of values for each node in the region.\n"
;

static const char symdiff_doc[] =
"    ds.symdiff (expr)\n"
"\n"
"    This command returns an expression.  All strings are treated as independent variables.  It is primarily used for defining new functions to the parser.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    expr : str\n"
"       Expression to send to SYMDIFF\n"
;

static const char vector_element_model_doc[] =
"    ds.vector_element_model (device, region, element_model)\n"
"\n"
"    Create vector components from an element edge model\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    element_model : str\n"
"       The element model for which we are calculating the vector compoenents\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    This command creates element edge models from an element model which represent the vector components on the element edge.  An element model, ``emodel``, would then have\n"
"\n"
"    - ``emodel_x``\n"
"    - ``emodel_y``\n"
"    - ``emodel_z`` (3D only)\n"
"\n"
"    The primary use of these components are for visualization.\n"
;

static const char vector_gradient_doc[] =
"    ds.vector_gradient (device, region, node_model, calc_type)\n"
"\n"
"    Creates the vector gradient for noise analysis\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    region : str\n"
"       The selected region\n"
"    node_model : str\n"
"       The node model from which we are creating the edge model\n"
"    calc_type : str, optional\n"
"       The node model from which we are creating the edge model (default 'default')\n"
"\n"
"    Notes\n"
"    -----\n"
"\n"
"    Used for noise analysis.  The ``avoidzero`` option is important for noise analysis, since a node model value of zero is not physical for some contact and interface boundary conditions.  For a given node model, ``model``, a node model is created in each direction:\n"
"\n"
"    - ``model_gradx`` (1D)\n"
"    - ``model_grady`` (2D and 3D)\n"
"    - ``model_gradz`` (3D)\n"
"\n"
"    It is important not to use these models for simulation, since DEVSIM, does not have a way of evaluating the derivatives of these models.  The models can be used for integrating the impedance field, and other postprocessing.  The :meth:`ds.element_from_edge_model` command can be used to create gradients for use in a simulation.\n"
;

static const char get_contact_charge_doc[] =
"    ds.get_contact_charge (device, contact, equation)\n"
"\n"
"    Get charge at the contact\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    equation : str\n"
"       Name of the contact equation from which we are retrieving the charge\n"
;

static const char get_contact_current_doc[] =
"    ds.get_contact_current (device, contact, equation)\n"
"\n"
"    Get current at the contact\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    device : str\n"
"       The selected device\n"
"    contact : str\n"
"       Contact on which to apply this command\n"
"    equation : str\n"
"       Name of the contact equation from which we are retrieving the current\n"
;

static const char solve_doc[] =
"    ds.solve (type, solver_type, absolute_error, relative_error, charge_error, gamma, tdelta, maximum_iterations, frequency, output_node, info)\n"
"\n"
"    Call the solver.  A small-signal AC source is set with the circuit voltage source.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    type : {'dc', 'ac', 'noise', 'transient_dc', 'transient_bdf1', 'transient_bdf2', 'transient_tr'} required\n"
"       type of solve being performed\n"
"    solver_type : {'direct', 'iterative'} required\n"
"       Linear solver type\n"
"    absolute_error : Float, optional\n"
"       Required update norm in the solve (default 0.0)\n"
"    relative_error : Float, optional\n"
"       Required relative update in the solve (default 0.0)\n"
"    charge_error : Float, optional\n"
"       Relative error between projected and solved charge during transient simulation (default 0.0)\n"
"    gamma : Float, optional\n"
"       Scaling factor for transient time step (default 1.0)\n"
"    tdelta : Float, optional\n"
"       time step (default 0.0)\n"
"    maximum_iterations : int, optional\n"
"       Maximum number of iterations in the DC solve (default 20)\n"
"    frequency : Float, optional\n"
"       Frequency for small-signal AC simulation (default 0.0)\n"
"    output_node : str, optional\n"
"       Output circuit node for noise simulation\n"
"    info : bool, optional\n"
"       Solve command return convergence information (default False)\n"
;
